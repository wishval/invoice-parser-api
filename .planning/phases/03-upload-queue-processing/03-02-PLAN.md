---
phase: 03-upload-queue-processing
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - app/Jobs/ProcessInvoice.php
  - app/Jobs/ConvertPdfToImages.php
  - app/Jobs/ParseInvoiceWithAI.php
  - app/Jobs/SaveParsedData.php
  - app/Jobs/CleanupTempFiles.php
  - app/Http/Controllers/Api/InvoiceController.php
  - routes/api.php
autonomous: true
requirements: [QUEU-01, QUEU-02, QUEU-03, QUEU-04, QUEU-05]

must_haves:
  truths:
    - "Invoice upload dispatches a chained job sequence to Redis queue"
    - "Jobs are chained sequentially: ProcessInvoice -> ConvertPdfToImages -> ParseInvoiceWithAI -> SaveParsedData -> CleanupTempFiles"
    - "Jobs are idempotent via ShouldBeUniqueUntilProcessing with invoice ID as unique key"
    - "Failed jobs are recorded in failed_jobs table with exception details"
    - "Invoice status updates from pending to processing when job starts"
    - "Invoice status updates to failed with error_message when job chain fails"
    - "User can check invoice status via GET /api/v1/invoices/{id}"
  artifacts:
    - path: "app/Jobs/ProcessInvoice.php"
      provides: "Orchestrator job that sets status to processing"
      contains: "ShouldBeUniqueUntilProcessing"
    - path: "app/Jobs/ConvertPdfToImages.php"
      provides: "Placeholder job for PDF-to-image conversion (Phase 4)"
      contains: "ShouldQueue"
    - path: "app/Jobs/ParseInvoiceWithAI.php"
      provides: "Placeholder job for AI parsing (Phase 4)"
      contains: "ShouldQueue"
    - path: "app/Jobs/SaveParsedData.php"
      provides: "Placeholder job for saving parsed data (Phase 4)"
      contains: "ShouldQueue"
    - path: "app/Jobs/CleanupTempFiles.php"
      provides: "Placeholder job for temp file cleanup (Phase 4)"
      contains: "ShouldQueue"
  key_links:
    - from: "app/Http/Controllers/Api/InvoiceController.php"
      to: "app/Jobs/ProcessInvoice.php"
      via: "Bus::chain() dispatch"
      pattern: "Bus::chain"
    - from: "app/Jobs/ProcessInvoice.php"
      to: "app/Models/Invoice.php"
      via: "status update to processing"
      pattern: "update.*status.*processing"
    - from: "Bus::chain catch callback"
      to: "app/Models/Invoice.php"
      via: "status update to failed on chain failure"
      pattern: "status.*failed"
---

<objective>
Implement the async job pipeline with chained jobs, idempotency, failure handling, status lifecycle, and a status check endpoint.

Purpose: Uploaded invoices are processed asynchronously through a reliable, idempotent job chain with observable status progression.
Output: Complete job chain infrastructure dispatched on upload, with status endpoint for monitoring.
</objective>

<execution_context>
@/Users/valerijbakalenko/.claude/get-shit-done/workflows/execute-plan.md
@/Users/valerijbakalenko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-upload-queue-processing/03-RESEARCH.md
@.planning/phases/03-upload-queue-processing/03-01-SUMMARY.md
@app/Models/Invoice.php
@app/Http/Controllers/Api/InvoiceController.php
@routes/api.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create job chain classes with idempotency and failure handling</name>
  <files>
    app/Jobs/ProcessInvoice.php
    app/Jobs/ConvertPdfToImages.php
    app/Jobs/ParseInvoiceWithAI.php
    app/Jobs/SaveParsedData.php
    app/Jobs/CleanupTempFiles.php
  </files>
  <action>
Create 5 job classes in app/Jobs/. All jobs share this base pattern:
- `implements ShouldQueue`
- `use Queueable;`
- Constructor takes `#[WithoutRelations] public Invoice $invoice`
- `public int $tries = 3;`
- `public int $timeout = 300;` (5 minutes)

**app/Jobs/ProcessInvoice.php** (the orchestrator):
- Additionally implements `ShouldBeUniqueUntilProcessing` (from `Illuminate\Contracts\Queue\ShouldBeUniqueUntilProcessing`)
- `public int $uniqueFor = 3600;` (1 hour lock)
- `uniqueId()` returns `"process-invoice-{$this->invoice->id}"`
- `handle()`: Updates invoice status to 'processing'. This is the first job in the chain -- it marks the start of processing. Log: `Log::info("Processing invoice {$this->invoice->id}")`
- `failed(Throwable $exception)`: Log error with invoice ID and exception message via `Log::error()`

**app/Jobs/ConvertPdfToImages.php** (placeholder for Phase 4):
- `handle()`: Log info "ConvertPdfToImages placeholder for invoice {id}". No actual conversion yet -- Phase 4 will implement this.
- `failed(Throwable $exception)`: Log error.

**app/Jobs/ParseInvoiceWithAI.php** (placeholder for Phase 4):
- `handle()`: Log info "ParseInvoiceWithAI placeholder for invoice {id}". Phase 4 will add OpenAI integration.
- `failed(Throwable $exception)`: Log error.

**app/Jobs/SaveParsedData.php** (placeholder for Phase 4):
- `handle()`: Log info "SaveParsedData placeholder for invoice {id}". Phase 4 will save extracted data.
- `failed(Throwable $exception)`: Log error.

**app/Jobs/CleanupTempFiles.php** (final job in chain):
- `handle()`: Updates invoice status to 'completed'. Log info "Invoice {id} processing completed". In Phase 4, this will also clean up temporary image files.
- `failed(Throwable $exception)`: Log error.

All jobs must import:
- `use App\Models\Invoice;`
- `use Illuminate\Contracts\Queue\ShouldQueue;`
- `use Illuminate\Foundation\Queue\Queueable;`
- `use Illuminate\Queue\Attributes\WithoutRelations;`
- `use Illuminate\Support\Facades\Log;`
- ProcessInvoice also imports `Illuminate\Contracts\Queue\ShouldBeUniqueUntilProcessing`
  </action>
  <verify>
Run: `docker-compose exec app php artisan tinker --execute="echo class_exists(App\Jobs\ProcessInvoice::class) ? 'ok' : 'fail';"` -- should print "ok".
Run: `docker-compose exec app php artisan tinker --execute="echo class_exists(App\Jobs\CleanupTempFiles::class) ? 'ok' : 'fail';"` -- should print "ok".
Run: `docker-compose exec app php artisan tinker --execute="\\$r = new ReflectionClass(App\Jobs\ProcessInvoice::class); echo implode(', ', array_map(fn(\\$i) => \\$i->getName(), \\$r->getInterfaces()));"` -- should include ShouldQueue and ShouldBeUniqueUntilProcessing.
  </verify>
  <done>Five job classes exist: ProcessInvoice (with ShouldBeUniqueUntilProcessing), ConvertPdfToImages, ParseInvoiceWithAI, SaveParsedData, CleanupTempFiles. All implement ShouldQueue, use WithoutRelations on Invoice parameter, have tries=3 and timeout=300, define handle() and failed() methods.</done>
</task>

<task type="auto">
  <name>Task 2: Wire job chain dispatch in controller and add status endpoint</name>
  <files>
    app/Http/Controllers/Api/InvoiceController.php
    routes/api.php
  </files>
  <action>
1. Update app/Http/Controllers/Api/InvoiceController.php:
   - Add imports for Bus facade and all 5 job classes
   - In the upload() method, REPLACE any existing placeholder dispatch with Bus::chain():
     ```php
     Bus::chain([
         new ProcessInvoice($invoice),
         new ConvertPdfToImages($invoice),
         new ParseInvoiceWithAI($invoice),
         new SaveParsedData($invoice),
         new CleanupTempFiles($invoice),
     ])
     ->onQueue('parse')
     ->catch(function (Throwable $e) use ($invoice) {
         $invoice->update([
             'status' => 'failed',
             'error_message' => Str::limit($e->getMessage(), 500),
         ]);
     })
     ->dispatch();
     ```
   - Import `use Illuminate\Support\Facades\Bus;` and `use Illuminate\Support\Str;` and `use Throwable;`

   - Add a new method show() for status checking:
     ```php
     public function show(Invoice $invoice): JsonResponse
     {
         // Ownership check: user can only see their own invoices
         if ($invoice->user_id !== auth()->id()) {
             abort(403, 'This invoice does not belong to you.');
         }

         return (new InvoiceResource($invoice))->response();
     }
     ```

2. Update routes/api.php:
   - Inside the auth:sanctum middleware group, add:
     `Route::get('/invoices/{invoice}', [InvoiceController::class, 'show']);`
   - Keep the existing POST /invoices route unchanged.

3. Verify the full flow works end-to-end by:
   - Starting a queue worker
   - Uploading a PDF
   - Checking that the job chain runs and status progresses to completed
  </action>
  <verify>
1. Get auth token: `TOKEN=$(curl -s http://localhost:8000/api/v1/login -H 'Content-Type: application/json' -d '{"email":"test@example.com","password":"password"}' | python3 -c "import sys,json; print(json.load(sys.stdin)['data']['token'])")`
2. Upload PDF: `RESPONSE=$(curl -s http://localhost:8000/api/v1/invoices -H "Authorization: Bearer $TOKEN" -F "pdf=@/tmp/test.pdf")` -- should return 202 with status "pending"
3. Extract invoice ID: `ID=$(echo $RESPONSE | python3 -c "import sys,json; print(json.load(sys.stdin)['data']['id'])")`
4. Start queue worker in background: `docker-compose exec -d app php artisan queue:work redis --queue=parse --once`
5. Wait 3 seconds, then check status: `curl -s http://localhost:8000/api/v1/invoices/$ID -H "Authorization: Bearer $TOKEN"` -- should show status "completed"
6. Verify ownership check: Create request without token or with different user -- should return 401 or 403
  </verify>
  <done>Upload endpoint dispatches Bus::chain with 5 sequential jobs on 'parse' queue. Chain catch handler sets invoice status to 'failed' with error message. GET /api/v1/invoices/{id} returns invoice status with ownership enforcement. Full flow: upload -> 202 pending -> queue worker -> processing -> completed.</done>
</task>

</tasks>

<verification>
1. Bus::chain dispatches 5 jobs in sequence on 'parse' queue
2. ProcessInvoice sets status to 'processing' when it runs
3. CleanupTempFiles sets status to 'completed' when chain finishes
4. Chain catch sets status to 'failed' with error_message when any job throws
5. ProcessInvoice implements ShouldBeUniqueUntilProcessing with invoice-scoped uniqueId
6. All jobs have tries=3 and failed() method for failed_jobs recording
7. GET /api/v1/invoices/{id} returns current invoice status
8. Status endpoint enforces user ownership (403 for other users' invoices)
9. Job chain uses afterCommit-safe dispatch (Bus::chain after create, no wrapping transaction)
</verification>

<success_criteria>
- Upload dispatches async job chain, not blocking HTTP response
- Jobs chained: ProcessInvoice -> ConvertPdfToImages -> ParseInvoiceWithAI -> SaveParsedData -> CleanupTempFiles
- Jobs are idempotent via ShouldBeUniqueUntilProcessing
- Failed jobs recorded in failed_jobs table
- Status lifecycle: pending -> processing -> completed (or failed)
- User can observe status via GET endpoint
</success_criteria>

<output>
After completion, create `.planning/phases/03-upload-queue-processing/03-02-SUMMARY.md`
</output>
