---
phase: 04-pdf-parsing-ai
plan: 03
type: execute
wave: 3
depends_on: [04-02]
files_modified:
  - app/Services/InvoiceValidator.php
  - app/Jobs/SaveParsedData.php
  - app/Jobs/CleanupTempFiles.php
  - database/migrations/2026_02_20_100000_add_confidence_scores_to_invoices_table.php
  - app/Models/Invoice.php
autonomous: true
requirements: [PARS-08, PARS-10]

must_haves:
  truths:
    - "Malformed OpenAI responses are rejected before any database write"
    - "Line item amounts are validated to sum within 0.01 tolerance of invoice totals"
    - "Valid data is persisted atomically: invoice fields + all line items in one transaction"
    - "Confidence scores are stored on the invoice record"
    - "Temp images and manifest/parsed JSON files are deleted after successful save"
  artifacts:
    - path: "app/Services/InvoiceValidator.php"
      provides: "Structural validation and totals math validation"
      min_lines: 40
    - path: "app/Jobs/SaveParsedData.php"
      provides: "Validates and persists parsed invoice data to DB"
      min_lines: 40
    - path: "app/Jobs/CleanupTempFiles.php"
      provides: "Deletes temp images and JSON files"
      min_lines: 20
    - path: "database/migrations/2026_02_20_100000_add_confidence_scores_to_invoices_table.php"
      provides: "JSON column for confidence scores"
  key_links:
    - from: "app/Jobs/SaveParsedData.php"
      to: "app/Services/InvoiceValidator.php"
      via: "validation call before DB write"
      pattern: "InvoiceValidator"
    - from: "app/Jobs/SaveParsedData.php"
      to: "app/Models/Invoice.php"
      via: "DB::transaction with update + items()->create"
      pattern: "DB::transaction"
    - from: "app/Jobs/CleanupTempFiles.php"
      to: "storage temp directory"
      via: "file deletion of manifest, parsed, and image files"
      pattern: "unlink|File::delete"
---

<objective>
Implement data validation, database persistence, and temp file cleanup to complete the parsing pipeline.

Purpose: The final jobs in the chain -- validate the AI-extracted data against business rules, persist to database atomically, store confidence scores, and clean up temporary files.
Output: Complete end-to-end parsing pipeline: upload -> convert -> parse -> validate -> save -> cleanup.
</objective>

<execution_context>
@/Users/valerijbakalenko/.claude/get-shit-done/workflows/execute-plan.md
@/Users/valerijbakalenko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-pdf-parsing-ai/04-RESEARCH.md
@.planning/phases/04-pdf-parsing-ai/04-02-SUMMARY.md
@app/Jobs/SaveParsedData.php
@app/Jobs/CleanupTempFiles.php
@app/Models/Invoice.php
@app/Models/InvoiceItem.php
@database/migrations/0001_01_01_000003_create_invoices_table.php
@database/migrations/0001_01_01_000004_create_invoice_items_table.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add confidence_scores migration and create InvoiceValidator service</name>
  <files>database/migrations/2026_02_20_100000_add_confidence_scores_to_invoices_table.php, app/Models/Invoice.php, app/Services/InvoiceValidator.php</files>
  <action>
1. Create migration `database/migrations/2026_02_20_100000_add_confidence_scores_to_invoices_table.php`:
   - Add `$table->json('confidence_scores')->nullable()` after the `total` column
   - Down: drop the column

2. Update `app/Models/Invoice.php`:
   - Add 'confidence_scores' to $fillable array
   - Add to $casts: `'confidence_scores' => 'array'`

3. Run migration inside Docker: `docker compose exec app php artisan migrate`

4. Create `app/Services/InvoiceValidator.php`:
   - Method: `validate(array $data): array` -- validates and returns validated data, throws InvalidArgumentException on failure
   - Use Laravel Validator facade with these rules:
     ```
     'vendor' => 'required|array'
     'vendor.name' => 'nullable|string|max:255'
     'vendor.address' => 'nullable|string'
     'vendor.tax_id' => 'nullable|string|max:50'
     'customer' => 'required|array'
     'customer.name' => 'nullable|string|max:255'
     'customer.address' => 'nullable|string'
     'customer.tax_id' => 'nullable|string|max:50'
     'metadata' => 'required|array'
     'metadata.invoice_number' => 'nullable|string|max:100'
     'metadata.invoice_date' => 'nullable|string|max:20'
     'metadata.due_date' => 'nullable|string|max:20'
     'metadata.currency' => 'nullable|string|max:3'
     'totals' => 'required|array'
     'totals.subtotal' => 'nullable|numeric|min:0'
     'totals.tax_amount' => 'nullable|numeric|min:0'
     'totals.total' => 'nullable|numeric|min:0'
     'line_items' => 'required|array|min:1'
     'line_items.*.description' => 'required|string|max:500'
     'line_items.*.quantity' => 'required|numeric|min:0'
     'line_items.*.unit_price' => 'required|numeric'
     'line_items.*.amount' => 'required|numeric'
     'line_items.*.tax' => 'nullable|numeric|min:0'
     'confidence' => 'required|array'
     'confidence.vendor' => 'required|integer|min:0|max:100'
     'confidence.customer' => 'required|integer|min:0|max:100'
     'confidence.metadata' => 'required|integer|min:0|max:100'
     'confidence.totals' => 'required|integer|min:0|max:100'
     'confidence.line_items' => 'required|integer|min:0|max:100'
     ```
   - If validation fails, throw InvalidArgumentException with first error message
   - Method: `validateTotals(array $data): void` -- validates line items sum against totals
     - Calculate: sum of line_items.*.amount = calculated_subtotal
     - Calculate: sum of line_items.*.tax (treating null as 0) = calculated_tax
     - Calculate: calculated_subtotal + calculated_tax = calculated_total
     - Compare calculated_total vs totals.total with 0.01 tolerance (abs diff)
     - If totals.total is null, skip validation (cannot validate against unknown total)
     - If mismatch exceeds tolerance, throw DomainException with descriptive message including both values
     - Log a warning (do not throw) if subtotal mismatch exceeds tolerance -- totals from AI may have rounding differences from line item sums
  </action>
  <verify>
- Migration file exists and adds confidence_scores JSON column
- `docker compose exec app php artisan migrate:status` shows the new migration as ran
- Invoice model has confidence_scores in fillable and casts
- `docker compose exec app php artisan tinker --execute="echo class_exists(\App\Services\InvoiceValidator::class) ? 'OK' : 'FAIL';"` outputs OK
  </verify>
  <done>confidence_scores JSON column added to invoices table. InvoiceValidator validates OpenAI response structure with Laravel rules AND validates line item totals with 0.01 tolerance.</done>
</task>

<task type="auto">
  <name>Task 2: Implement SaveParsedData and CleanupTempFiles jobs</name>
  <files>app/Jobs/SaveParsedData.php, app/Jobs/CleanupTempFiles.php</files>
  <action>
Update `app/Jobs/SaveParsedData.php` (replace the stub):
- Keep existing: tries=3, timeout=300, WithoutRelations, failed() method
- In handle():
  1. Read parsed JSON: `$parsedPath = storage_path("app/temp/invoice_{$this->invoice->id}_parsed.json")`
  2. If file does not exist, throw RuntimeException("Parsed data not found for invoice {$this->invoice->id}")
  3. Decode JSON: `$data = json_decode(file_get_contents($parsedPath), true)`
  4. Validate structure: `$validator = new \App\Services\InvoiceValidator(); $validator->validate($data);`
  5. Validate totals: `$validator->validateTotals($data);`
  6. Wrap persistence in DB::transaction:
     - Update invoice with all extracted fields:
       - vendor_name, vendor_address, vendor_tax_id (from data['vendor'])
       - customer_name, customer_address, customer_tax_id (from data['customer'])
       - invoice_number, invoice_date, due_date, currency (from data['metadata'])
       - subtotal, tax_amount, total (from data['totals'])
       - confidence_scores (from data['confidence'])
       - status: 'completed'
     - For invoice_date and due_date: parse string to Carbon date if not null, use Carbon::parse() with try/catch -- set to null if unparseable
     - Delete existing invoice items first (idempotency on retry): `$this->invoice->items()->delete()`
     - Create each line item via `$this->invoice->items()->create([...])` with description, quantity, unit_price, amount, tax
  7. Log success with invoice ID and line item count
- In failed(): update status to 'failed' with error message (same pattern as other jobs)

Update `app/Jobs/CleanupTempFiles.php` (replace the stub):
- Keep existing: tries=3, timeout=300, WithoutRelations, failed() method
- In handle():
  1. Read manifest file to get image paths: `storage_path("app/temp/invoice_{$this->invoice->id}_manifest.json")`
  2. If manifest exists, decode and delete each image file (use File::delete, ignore missing files)
  3. Delete the manifest file itself
  4. Delete the parsed JSON file: `storage_path("app/temp/invoice_{$this->invoice->id}_parsed.json")`
  5. Log cleanup completion with invoice ID
  6. Do NOT update status here -- SaveParsedData already set it to 'completed'. CleanupTempFiles only cleans files.
  7. If status is already 'completed', leave it. If not (edge case), do not change it.

Important: Remove the `$this->invoice->update(['status' => 'completed'])` from CleanupTempFiles -- that responsibility moved to SaveParsedData where it belongs (atomic with the data save).
  </action>
  <verify>
- `app/Jobs/SaveParsedData.php` contains DB::transaction, InvoiceValidator, items()->create
- `app/Jobs/CleanupTempFiles.php` deletes manifest, parsed JSON, and image files
- Neither file contains "placeholder" text
- SaveParsedData sets status to 'completed' inside transaction
- CleanupTempFiles does NOT set status (removed from stub)
  </verify>
  <done>SaveParsedData validates AI response, persists invoice data + line items atomically in a transaction, stores confidence scores. CleanupTempFiles removes all temp images and JSON files. Full pipeline: upload -> convert -> parse -> validate+save -> cleanup.</done>
</task>

</tasks>

<verification>
- Full job chain is implemented: ProcessInvoice (status) -> ConvertPdfToImages (images) -> ParseInvoiceWithAI (AI) -> SaveParsedData (validate+persist) -> CleanupTempFiles (cleanup)
- No stub/placeholder jobs remain
- InvoiceValidator catches malformed responses before DB write (PARS-08)
- Line item totals validated with 0.01 tolerance (PARS-10)
- Confidence scores stored as JSON on invoice (PARS-09)
- All data persisted in DB::transaction for atomicity
- Temp files cleaned up after successful processing
</verification>

<success_criteria>
- Malformed OpenAI responses rejected by InvoiceValidator before any database write
- Line items sum validated against invoice total within 0.01 tolerance
- Invoice data + line items saved atomically in single DB transaction
- Confidence scores persisted as JSON array on invoice record
- All temp files (images, manifest, parsed JSON) cleaned up after processing
- Invoice status transitions: pending -> processing -> completed (or failed at any step)
</success_criteria>

<output>
After completion, create `.planning/phases/04-pdf-parsing-ai/04-03-SUMMARY.md`
</output>
