---
phase: 02-auth-api-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/Models/User.php
  - app/Http/Controllers/Api/AuthController.php
  - app/Http/Resources/UserResource.php
  - database/seeders/DatabaseSeeder.php
  - routes/api.php
autonomous: true
requirements: [AUTH-01, AUTH-02, AUTH-03, INFR-02]

must_haves:
  truths:
    - "User can POST /api/v1/login with email+password and receive a bearer token"
    - "User can POST /api/v1/logout with bearer token and the token is revoked"
    - "Test user (test@example.com / password) exists after seeding"
    - "Login response returns user data through UserResource (not raw model)"
  artifacts:
    - path: "app/Http/Controllers/Api/AuthController.php"
      provides: "Login and logout endpoints"
      exports: ["login", "logout"]
    - path: "app/Http/Resources/UserResource.php"
      provides: "Consistent JSON transformation for User model"
      exports: ["UserResource"]
    - path: "app/Models/User.php"
      provides: "User model with HasApiTokens trait"
      contains: "HasApiTokens"
    - path: "database/seeders/DatabaseSeeder.php"
      provides: "Test user seeder"
      contains: "test@example.com"
    - path: "routes/api.php"
      provides: "Auth routes under /api/v1/"
      contains: "login"
  key_links:
    - from: "routes/api.php"
      to: "app/Http/Controllers/Api/AuthController.php"
      via: "Route::post login/logout"
      pattern: "AuthController::class"
    - from: "app/Http/Controllers/Api/AuthController.php"
      to: "app/Http/Resources/UserResource.php"
      via: "new UserResource in login response"
      pattern: "new UserResource"
    - from: "app/Http/Controllers/Api/AuthController.php"
      to: "app/Models/User.php"
      via: "createToken and currentAccessToken"
      pattern: "createToken|currentAccessToken"
---

<objective>
Implement Sanctum token authentication (login/logout), test user seeder, and API Resource layer.

Purpose: Users can authenticate with email/password to get a bearer token for subsequent API requests. A test user exists for development/demo. All user data responses use API Resources for consistent JSON structure.
Output: AuthController with login/logout, UserResource, updated User model with HasApiTokens, test user seeder, auth routes.
</objective>

<execution_context>
@/Users/valerijbakalenko/.claude/get-shit-done/workflows/execute-plan.md
@/Users/valerijbakalenko/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-auth-api-infrastructure/02-RESEARCH.md
@bootstrap/app.php
@routes/api.php
@app/Models/User.php
@database/seeders/DatabaseSeeder.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: User model, seeder, and UserResource</name>
  <files>
    app/Models/User.php
    app/Http/Resources/UserResource.php
    database/seeders/DatabaseSeeder.php
  </files>
  <action>
    1. Add HasApiTokens trait to User model (app/Models/User.php):
       - Add `use Laravel\Sanctum\HasApiTokens;` import
       - Add `HasApiTokens` to the trait list: `use HasFactory, Notifiable, HasApiTokens;`
       - Keep existing fillable, hidden, and casts unchanged

    2. Create UserResource (app/Http/Resources/UserResource.php):
       - Extend JsonResource
       - toArray() returns: id, name, email, created_at, updated_at
       - Do NOT expose password, remember_token, or email_verified_at

    3. Update DatabaseSeeder (database/seeders/DatabaseSeeder.php):
       - Use User::factory()->create() with name 'Test User', email 'test@example.com'
       - The factory already hashes passwords via the 'password' => 'hashed' cast, so default factory password works
       - Add a comment documenting the test credentials: email test@example.com, password "password"
       - Wrap in a check: only create if user with that email doesn't already exist (idempotent seeding)

    Run seeder inside Docker: `docker-compose exec app php artisan db:seed`
  </action>
  <verify>
    - `docker-compose exec app php artisan tinker --execute="echo App\Models\User::where('email','test@example.com')->exists() ? 'EXISTS' : 'MISSING';"` outputs EXISTS
    - `docker-compose exec app php artisan tinker --execute="echo in_array('Laravel\Sanctum\HasApiTokens', class_uses_recursive(App\Models\User::class)) ? 'HAS_TRAIT' : 'MISSING';"` outputs HAS_TRAIT
  </verify>
  <done>User model has HasApiTokens trait, UserResource transforms user to JSON without sensitive fields, test user exists in database with known credentials.</done>
</task>

<task type="auto">
  <name>Task 2: AuthController and auth routes</name>
  <files>
    app/Http/Controllers/Api/AuthController.php
    routes/api.php
  </files>
  <action>
    1. Create AuthController (app/Http/Controllers/Api/AuthController.php):
       - Namespace: App\Http\Controllers\Api
       - Extends base Controller

       login() method:
       - Validate: email (required|email), password (required)
       - Find user by email, verify password with Hash::check()
       - If credentials invalid: throw ValidationException::withMessages(['email' => ['The provided credentials are incorrect.']])
       - Create token: $user->createToken('api-client')->plainTextToken
       - Return JSON response with 'token' and 'user' (wrapped in new UserResource($user))

       logout() method:
       - $request->user()->currentAccessToken()->delete() -- revokes ONLY the current token, not all tokens
       - Return JSON: ['message' => 'Logged out successfully']

    2. Update routes/api.php:
       - Keep existing /health route
       - Add public route: Route::post('/login', [AuthController::class, 'login'])
       - Add protected route group with auth:sanctum middleware:
         - Route::post('/logout', [AuthController::class, 'logout'])
         - Route::get('/user', fn(Request $request) => new UserResource($request->user())) -- returns authenticated user
       - Import AuthController and UserResource at top

    Do NOT add rate limiting middleware here -- that is Plan 02's responsibility.
  </action>
  <verify>
    Test login: `docker-compose exec app php artisan tinker --execute="
      \$response = app()->handle(\Illuminate\Http\Request::create('/api/v1/login', 'POST', ['email' => 'test@example.com', 'password' => 'password']));
      echo \$response->getStatusCode() . ' ' . \$response->getContent();
    "`
    Should return 200 with JSON containing 'token' and 'user' keys.

    Test invalid login: same but with wrong password, should return 422.

    Test logout: Use the token from login to call /api/v1/logout, should return 200.
  </verify>
  <done>POST /api/v1/login returns 200 with token + user for valid credentials, 422 for invalid. POST /api/v1/logout with bearer token returns 200 and revokes the token. GET /api/v1/user returns authenticated user via UserResource.</done>
</task>

</tasks>

<verification>
1. Login flow: POST /api/v1/login with test@example.com/password returns 200 + token + user object
2. Invalid login: POST /api/v1/login with wrong password returns 422 with validation error
3. Protected route: GET /api/v1/user with bearer token returns user JSON (id, name, email, timestamps)
4. Unauthenticated access: GET /api/v1/user without token returns 401
5. Logout: POST /api/v1/logout with token returns 200, subsequent request with same token returns 401
6. UserResource: Login and /user responses contain only id, name, email, created_at, updated_at (no password hash)
</verification>

<success_criteria>
- Valid credentials produce a bearer token that authenticates subsequent requests
- Invalid credentials return 422 with structured error message
- Logout revokes only the current token
- Test user exists and can authenticate
- All user data returned through UserResource (consistent JSON, no sensitive fields)
</success_criteria>

<output>
After completion, create `.planning/phases/02-auth-api-infrastructure/02-01-SUMMARY.md`
</output>
